R"RU0(

# Throws an error caught by a try-catch loop
throw(e) => {
	_OUTER_CALL_("error", e);
};

static os :: {
	system(x) => { _OUTER_CALL_("console.system", x)[0] };
	getenv(v) => { _OUTER_CALL_("console.getenv", v)[0] };
	exit() => { _OUTER_CALL_("console.exit") };
	rawFile(filename) => { _OUTER_CALL_("console.raw_file", filename)[0] };
	milli() => { _OUTER_CALL_("console.milli")[0] };
};

static System :: {
	path() => { _OUTER_CALL_("filesystem.path")[0] };
	dir(path = "") => { _OUTER_CALL_("filesystem.listdir", path) };
	exists(path) => { _OUTER_CALL_("filesystem.exists", path)[0] };
	mkdir(path) => { _OUTER_CALL_("filesystem.mkdir", path) };
	remove(path) => { _OUTER_CALL_("filesystem.remove", path) };
	size(path) => { _OUTER_CALL_("filesystem.size", path)[0] };
	copy(origin, path) => { _OUTER_CALL_("filesystem.copy", origin, path) };
	rename(origin, path) => { _OUTER_CALL_("filesystem.rename", origin, path) };
};

# DEPRECATED - use new for loop syntax:
# DO:		(first, second) in (a, b) ->> { ... };
# DO NOT:	k in pairs(a, b) ->> { ... };
# Returns a paired object array built from the contents of two equally sized arrays
# pairs(&a, &b) => p from {
# 	len a != len b then return;
# 	p = (i in [0 : len a] ->> {
# 		struct {
# 			first :&= a[i]; 
# 			second :&= b[i];	
# 			string() => { first .. "=" .. second };
# 		};
# 	});
# };

# Returns every combination of arrays a and b
lace(&a, &b) => t from {
	t = [];
	i in a ->> j in b ->> {
		t push struct {
			first :&= i;
			second :&= j;
			string() => { "(" .. first .. ", " .. second .. ")" };
		};
	};
};

static Math :: {
	PI := 3.141593;
	floor(x) => { _OUTER_CALL_("console.floor", num x)[0] };
	sqrt(x) => { x ** 0.5 };
	max(&a, &b) => { a > b then a else b };
	min(&a, &b) => { a < b then a else b };
	abs(a) => { a < 0 then -a else a };
	round(a, d) => r from {
  		m := 10 ** (d != null then d else 0);
  		r = floor(num a * m + 0.5) / m;
	};
	ceil(a) => { floor(a) == a then a else floor(a) + 1 };

	sum(a) => s from {
		s = 0;
		i in a ->> {
			s = s + i;
		};
	};
	prod(a) => p from {
		p = 1;
		i in a ->> {
			p = p * i;
		};
	};
	fact(x) => { x >= 2 then x * idem(x - 1) else x };

	# TRIG
	cos(x, t = 10) => s from {
		x >= 2 * PI do x -= 2 * PI;
		x <= -2 * PI do x += 2 * PI;
		s = 0;
		i in [0 : t] ->> {
			s += (-1 ** i) * (x ** (2 * i)) / fact(2 * i);
		};
	};

	sin(x, t = 10) => s from {
		x >= 2 * PI do x -= 2 * PI;
		x <= -2 * PI do x += 2 * PI;
		s = 0;
		i in [0 : t] ->> {
			s += (-1 ** i) * (x ** (2 * i + 1)) / fact(2 * i + 1);
		};
	};

	tan(x, t) => { sin(x, t) / cos(x, t) };

	exp(x, t = 10) => s from {
		s = 0;
		i in [0 : t] ->> {
			s += (x ** i) / fact(i);
		};
	};
};

static Random :: {
	double() => { _OUTER_CALL_("console.random")[0] };
	int(min, max) => i from {
		max == null then {
			max = min;
			min = 0;
		};
		i = Math.floor(double() * (max - min) + min);
	};
	list(&a) => { a[int(0, len a)] };
};

static Regex :: {
	search(s, e) => { _OUTER_CALL_("regex.search", s, e) };
	replace(s, r, e) => { _OUTER_CALL_("regex.replace", s, r, e)[0] };
};

dynamic File :: {
	var ptr;
	var mode;
	
	init(filename, mode='r') => {
		self.mode = mode;
		mode switch {
		'r' >> { ptr = _OUTER_CALL_("file.open", filename)[0] };
		'w' >> { ptr = _OUTER_CALL_("filew.open", filename, mode)[0] };
		'a' >> { ptr = _OUTER_CALL_("filew.open", filename, mode)[0]; self.mode = 'w' };
		};
	};

	write(s) => {
		ptr == null then throw("Error: file closed!");
		mode == 'r' then throw("Error: file openned in read mode!");
		_OUTER_CALL_("filew.write", ptr, s);
	};

	readLine() => t from {
		ptr == null then throw("Error: file closed!");
		mode == 'w' then throw("Error: file openned in write mode!");
		t = _OUTER_CALL_("file.read_line", ptr)[0];
	};

	readAll() => t from {
		ptr == null then throw("Error: file closed!");
		mode == 'w' then throw("Error: file openned in write mode!");
		line := "";
		t = "";
		(line = readLine()) != null do {
			t ..= line .. "\n";
		};
	};

	read(length = 1) => t from {
		ptr == null then throw("Error: file closed!");
		mode == 'w' then throw("Error: file openned in write mode!");
		t = _OUTER_CALL_("file.read", ptr, length)[0];
	};

	close() => {
		ptr == null then throw("Error: file closed!");
		mode switch {
		'r' >> _OUTER_CALL_("file.close", ptr);
		'w' >> _OUTER_CALL_("filew.close", ptr);
		};
		ptr = null;
	};
};

static Winsock :: {
	# Activates the Winsock API
	start() => { 
		r := _OUTER_CALL_("winsock.start")[0];
		r != null then throw(r);
	};
	# Returns a newly created Socket
	createSocket() => socket from {
		r := _OUTER_CALL_("winsock.create_socket");
		r[0] != null then throw(r[0]);
		socket = new Socket(r[1]);
	};
	# Returns a list of addresses from a given url
	getAddresses(url) => { _OUTER_CALL_("winsock.get_addresses", url) };

	dynamic Socket :: {
		ptr := null;
		init(ptr) => {
			self.ptr = ptr;
		};
		# Connects to an address (url or IP) on a given port
		connect(addr, port) => {
			c in addr ->> { 
				!(c == '.' && c > '0' && c < '9') then {
					addr = Winsock.getAddresses(addr)[0]; 
					break; 
				};
			};
			r := _OUTER_CALL_("winsock.connect", ptr, str addr, num port)[0];
			r != null then throw(r);
		};
		# Sends data to the connected server
		send(value) => {
			r := _OUTER_CALL_("winsock.send", ptr, value)[0];
			r != null then throw(r);
		};
		# Receives data up to a given amount of bytes from server
		# If no callback is given, the function waits until it recieves
		# a response and then returns the function. If a callback is given,
		# it detaches the receiving function from the main thread and calls
		# the callback when it receives the answer, passing the value to
		# the callback.
		receive(bytes = 512, callback = null) => r from {
			callback != null then {
				detach callback(_OUTER_CALL_("winsock.receive", ptr, bytes)[0]);
			} else {
				r = _OUTER_CALL_("winsock.receive", ptr, bytes)[0];
			};
		};
		# Listens continuously, requires a callback
		# Blocking can be specified, defaults to 'false'
		listen(callback, bytes = 512, blocking = false) => {
			blocking then {
				_OUTER_CALL_("winsock.listen", ptr, bytes, callback);
			} else {
				detach _OUTER_CALL_("winsock.listen", ptr, bytes, callback);
			};
		};
		shutdown() => {
			r := _OUTER_CALL_("winsock.shutdown", ptr)[0];
			r != null then throw(r);
		};
	};
};

)RU0"